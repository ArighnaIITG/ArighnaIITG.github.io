---
layout: post
title: GSoC Week 4 !!
subtitle: Week 4 ends..
gh-repo: ArighnaIITG/arighnaiitg.github.io
gh-badge: [star, fork, follow]
bigimg: /img/gsoc1.jpg
tags: [gsoc, sympy, week 4]
comments: true
---

Week 4 and the final week of the first phase of the Coding Period is coming to an end. The work, which was initially proposed to be done in `FormalPowerSeries` has been done on a term-by-term level, i.e. the operations which have been implemented return truncated terms of the resultant `FormalPowerSeries`, instead of returning a `FormalPowerSeries` object. Sartaj and I have already discussed about the `class` implementation, in a recent meeting. Here are the deliverables which has been completed this week :--

   - The [PR #17017](https://github.com/sympy/sympy/pull/17017) consisted of a `convolve` function, which takes in a order `n` term, and returns the truncated terms of the resultant convoluted formal power series. The `API` of the `convolve` function was in line with the `convolution` function in `sympy.discrete.convolutions`. More specifically, it was --
   ```javascript
   def convolve(self, other, x=None, n=6, cycle=0, dyadic=False, subset=False):
        """The logic of the code"""
   ```
Sartaj suggested that there should be a **method** kwarg, which can take in which `method` of convolution the user wants to apply, instead of passing various kwargs representing the various methods. So I changed the `API` of the function, in lines with the above comment. Currently it is --
   ```javascript
   def convolve(self, other, x=None, n=6, cycle=0, method=None):
        """The logic of the code"""
   ```
in which method will be one of `[dyadic, subset, None]`, and cycle will represent the no. of cycles in cyclic convolution. Docs have also been updated. The PR is now in a mergeable state !!

  - I also opened a [PR #17064], which deals with the `composition` and `inversion` of formal power series. I had implemented a `CoeffBell` class, where essentially `CoeffBellCompose(f, n, k) represents Bell polynomials of the second kind`. Note that both ``n`` and ``k`` should be integers. The implementation of the `eval` function of the `CoeffBell` class is as follows --
```javascript
@classmethod
def eval(cls, f, n, k):
    fp = fps(f)
    kv = fp.ak.variables[0]
    i = symbols('i')

    if n.is_integer and k.is_integer:
        fp_seq = sequence(fp.ak.formula, (kv, 1, n-k+1))
        fact_seq = sequence(factorial(i), (i, 1, n-k+1))
        bell_seq = fp_seq * fact_seq
        return bell(n, k, tuple(bell_seq))
 ```
 
